<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<!--<![endif]-->

<head>
  <title>【爬虫系列】4、解析库和数据库 | 方糖~</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="方糖~">
    <meta name="author" content="Yu Fangheng">
    <meta name="description" content="Henry's Blog~" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/HenryBalthier.github.io/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="方糖~" type="application/atom+xml">
    <link rel="stylesheet" href="/HenryBalthier.github.io/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/HenryBalthier.github.io/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/HenryBalthier.github.io/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/HenryBalthier.github.io/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/HenryBalthier.github.io/js/html5shiv.min.js"></script>
    <script src="/HenryBalthier.github.io/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/HenryBalthier.github.io/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/HenryBalthier.github.io/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/HenryBalthier.github.io/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="https://henrybalthier.github.io/HenryBalthier.github.io/tags/python/" target="_BLANK" class="animsition-link">Python</a></li>
                    
                        <li><a href="https://henrybalthier.github.io/HenryBalthier.github.io/tags/Linux/" target="_BLANK" class="animsition-link">Linux</a></li>
                    
                        <li><a href="https://henrybalthier.github.io/HenryBalthier.github.io/tags/Java/" target="_BLANK" class="animsition-link">Java</a></li>
                    
                        <li><a href="https://henrybalthier.github.io/HenryBalthier.github.io/tags/%E7%AE%97%E6%B3%95/" target="_BLANK" class="animsition-link">算法</a></li>
                    
                </ul>
            </li>
            
            
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            <li><a href="/HenryBalthier.github.io/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/HenryBalthier.github.io/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">方糖~</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2017-08-31T06:52:40.000Z" itemprop="datePublished">
          2017-08-31
      </time>
    
    
    | 
    <a href='/HenryBalthier.github.io/tags/爬虫/'>爬虫</a>
    
    
</span>
                <h1>【爬虫系列】4、解析库和数据库</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h4 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h4><ul>
<li>解析库：Xpath、BeautifulSoup、PyQuery</li>
<li>数据库：MySQL、MongoDB、Redis</li>
</ul>
<a id="more"></a>
<hr>
<h4 id="爬虫学习参考网站："><a href="#爬虫学习参考网站：" class="headerlink" title="爬虫学习参考网站："></a>爬虫学习参考网站：</h4><p><a href="https://germey.gitbooks.io/python3webspider/content/0-%E7%9B%AE%E5%BD%95.html" target="_blank" rel="external">Python3爬虫实战</a></p>
<p>　　上一节我们实现了一个最基本的爬虫，但提取页面信息时我们使用的是正则表达式，用过之后我们会发现构造一个正则表达式还是比较的繁琐的，而且万一有一点地方写错了就可能会导致匹配失败，所以使用正则来提取页面信息多多少少还是有些不方便的。</p>
<p>　　对于网页的节点来说，它可以定义 id、class 或其他的属性，而且节点之间还具有层次关系，在网页中可以通过 XPath 或 CSS 选择器来定位一个或多个节点。那么在页面解析时，我们利用 XPath 或 CSS 选择器来提取到某个节点，然后再调用相应的方法去获取它的正文内容或者属性不就可以提取我们想要的任意信息了吗？</p>
<p>　　在 Python 中，我们怎样来实现这个操作呢？不用担心，这种解析库已经非常多了，其中比较强大的库有 LXML、BeautifulSoup、PyQuery 等等</p>
<h2 id="4-1、XPath使用"><a href="#4-1、XPath使用" class="headerlink" title="4.1、XPath使用"></a>4.1、XPath使用</h2><p>　　XPath，全称 XML Path Language，即 XML 路径语言，它是一门在XML文档中查找信息的语言。XPath 最初设计是用来搜寻XML文档的，但是它同样适用于 HTML 文档的搜索。</p>
<p>　　所以在做爬虫时，我们完全可以使用 XPath 来做相应的信息抽取，它提供了非常简洁明了的路径选择表达式，另外它还提供了超过 100 个内建函数用于字符串、数值、时间的匹配以及节点、序列的处理等等，几乎所有我们想要定位的节点都可以用XPath来选择。</p>
<p>　　在这里列出了XPath的常用匹配规则，例如 / 代表选取直接子节点，// 代表选择所有子孙节点，. 代表选取当前节点，.. 代表选取当前节点的父节点，@ 则是加了属性的限定，选取匹配属性的特定节点。</p>
<p>　　例如：</p>
<pre><code>//title[@lang=’eng’]
</code></pre><p>　　这就是一个 XPath 规则，它就代表选择所有名称为 title，同时属性 lang 的值为 eng 的节点。</p>
<p><strong>所有节点</strong></p>
<p>　　我们一般会用 // 开头的 XPath 规则来选取所有符合要求的节点，以上文的 HTML 文本为例，如果我们要选取所有节点，可以这样实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</div><div class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</div><div class="line">result = html.xpath(<span class="string">'//*'</span>)</div><div class="line">print(result)</div></pre></td></tr></table></figure></p>
<p>　　运行结果：</p>
<pre><code>[&lt;Element html at 0x10510d9c8&gt;, &lt;Element body at 0x10510da08&gt;, &lt;Element div at 0x10510da48&gt;, &lt;Element ul at 0x10510da88&gt;, &lt;Element li at 0x10510dac8&gt;, &lt;Element a at 0x10510db48&gt;, &lt;Element li at 0x10510db88&gt;, &lt;Element a at 0x10510dbc8&gt;, &lt;Element li at 0x10510dc08&gt;, &lt;Element a at 0x10510db08&gt;, &lt;Element li at 0x10510dc48&gt;, &lt;Element a at 0x10510dc88&gt;, &lt;Element li at 0x10510dcc8&gt;, &lt;Element a at 0x10510dd08&gt;]
</code></pre><p>　　我们在这里使用 * 代表匹配所有节点，也就是整个 HTML 文本中的所有节点都会被获取，可以看到返回形式是一个列表，每个元素是 Element 类型，其后跟了节点的名称，如 html、body、div、ul、li、a 等等，所有的节点都包含在列表中了。</p>
<p>　　当然此处匹配也可以指定节点名称，如果我们想获取所有 li 节点，示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</div><div class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</div><div class="line">result = html.xpath(<span class="string">'//li'</span>)</div><div class="line">print(result)</div><div class="line">print(result[<span class="number">0</span>])</div></pre></td></tr></table></figure></p>
<p>　　在这里我们要选取所有 li 节点可以使用 //，然后直接加上节点的名称即可，调用时直接调用 xpath() 方法即可提取。</p>
<p>　　运行结果：</p>
<pre><code>[&lt;Element li at 0x105849208&gt;, &lt;Element li at 0x105849248&gt;, &lt;Element li at 0x105849288&gt;, &lt;Element li at 0x1058492c8&gt;, &lt;Element li at 0x105849308&gt;]
&lt;Element li at 0x105849208&gt;
</code></pre><p>　　在这里我们可以看到提取结果是一个列表形式，其每一个元素都是一个 Element 对象，如果要取出其中一个对象可以直接用中括号加索引即可取出，如 [0]。</p>
<p><strong>子节点</strong></p>
<p>　　我们通过 / 或 // 即可查找元素的子节点或子孙节点，加入我们现在想选择 li 节点所有直接 a 子节点，可以这样来实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</div><div class="line"></div><div class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</div><div class="line">result = html.xpath(<span class="string">'//li/a'</span>)</div></pre></td></tr></table></figure></p>
<p><strong>属性匹配</strong></p>
<p>　　在选取的时候我们还可以用 @ 符号进行属性过滤，比如在这里如果我们要选取 class 为 item-1 的 li 节点，可以这样实现:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    from lxml import etree</div><div class="line">    html = etree.parse('./test.html', etree.HTMLParser())</div><div class="line">    result = html.xpath('//li[@class="item-0"]')</div><div class="line">    print(result)</div><div class="line">```   </div><div class="line">　　在这里我们通过加入 [@class="item-0"] 就限制了节点的 class 属性为 item-0，而 HTML 文本中符合条件的 li 节点有两个，所以返回结果应该返回两个匹配到的元素，结果如下：</div><div class="line"></div><div class="line">    [&lt;Element li at 0x10a399288&gt;, &lt;Element li at 0x10a3992c8&gt;]</div><div class="line">    </div><div class="line">　　可见匹配结果结果正是两个，至于是不是那正确的两个，我们在后面验证一下。</div><div class="line"></div><div class="line">**文本获取**</div><div class="line"></div><div class="line">　　我们用 XPath 中的 text() 方法可以获取节点中的文本，我们接下来尝试获取一下上文 li 节点中的文本，代码如下：</div><div class="line">```python</div><div class="line">    from lxml import etree</div><div class="line">    </div><div class="line">    html = etree.parse('./test.html', etree.HTMLParser())</div><div class="line">    result = html.xpath('//li[@class="item-0"]/text()')</div><div class="line">    print(result)</div></pre></td></tr></table></figure></p>
<p>　　运行结果如下：</p>
<pre><code>[&apos;\n     &apos;]
</code></pre><p>　　很奇怪的是我们并没有获取到任何文本，而是只获取到了一个换行符，这是为什么呢？因为 XPath 中 text() 前面是 /，而此 / 的含义是选取直接子节点，而此处很明显 li 的直接子节点都是 a 节点，文本都是在 a 节点内部的，所以这里匹配到的结果就是被修正的 li 节点内部的换行符，因为自动修正的li节点的尾标签换行了。</p>
<p>　　即选中的是这两个节点：</p>
<pre><code>&lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;
&lt;/li&gt;
</code></pre><p>　　其中一个节点因为自动修正，li 节点的尾标签添加的时候换行了，所以提取文本得到的唯一结果就是 li 节点的尾标签和 a 节点的尾标签之间的换行符。</p>
<p>　　因此，如果我们想获取 li 节点内部的文本就有两种方式，一种是选取到 a 节点再获取文本，另一种就是使用 //，我们来看下二者的区别是什么。</p>
<p>　　首先我们选取到 a 节点再获取文本，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</div><div class="line"></div><div class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</div><div class="line">result = html.xpath(<span class="string">'//li[@class="item-0"]/a/text()'</span>)</div><div class="line">print(result)</div></pre></td></tr></table></figure></p>
<p>　　运行结果：</p>
<pre><code>[&apos;first item&apos;, &apos;fifth item&apos;]
</code></pre><p>　　可以看到这里返回值是两个，内容都是属性为 item-0 的 li 节点的文本，这也印证了我们上文中属性匹配的结果是正确的。</p>
<p>　　在这里我们是逐层选取的，先选取了 li 节点，又利用 / 选取了其直接子节点 a，然后再选取其文本，得到的结果恰好是符合我们预期的两个结果。</p>
<p>　　我们再来看下用另一种方式 // 选取的结果，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</div><div class="line"></div><div class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</div><div class="line">result = html.xpath(<span class="string">'//li[@class="item-0"]//text()'</span>)</div><div class="line">print(result)</div></pre></td></tr></table></figure></p>
<p>　　运行结果：</p>
<pre><code>[&apos;first item&apos;, &apos;fifth item&apos;, &apos;\n     &apos;]
</code></pre><p>　　不出所料，这里返回结果是三个，可想而知这里是选取所有子孙节点的文本，其中前两个就是 li 的子节点 a 节点内部的文本，另外一个就是最后一个 li 节点内部的文本，即换行符。</p>
<p>　　所以说，如果我们要想获取子孙节点内部的所有文本，可以直接用 // 加 text() 的方式获取，这样可以保证获取到最全面的文本信息，但是可能会夹杂一些换行符等特殊字符。如果我们想获取某些特定子孙节点下的所有文本，可以先选取到特定的子孙节点，然后再调用 text() 方法获取其内部文本，这样可以保证获取的结果是整洁的。</p>
<p><strong>属性获取</strong></p>
<p>　　我们知道了用 text() 可以获取节点内部文本，那么节点属性该怎样获取呢？其实还是用 @ 符号就可以，例如我们想获取所有 li 节点下所有 a 节点的 href 属性，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</div><div class="line"></div><div class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</div><div class="line">result = html.xpath(<span class="string">'//li/a/@href'</span>)</div><div class="line">print(result)</div></pre></td></tr></table></figure></p>
<p>　　在这里我们通过 @href 即可获取节点的 href 属性，注意此处和属性匹配的方法不同，属性匹配是中括号加属性名和值来限定某个属性，如 [@href=”link1.html”]，而此处的 @href 指的是获取节点的某个属性，二者需要做好区分。</p>
<p>　　运行结果：</p>
<pre><code>[&apos;link1.html&apos;, &apos;link2.html&apos;, &apos;link3.html&apos;, &apos;link4.html&apos;, &apos;link5.html&apos;]
</code></pre><p>　　可以看到我们成功获取了所有 li 节点下的 a 节点的 href 属性，以列表形式返回。</p>
<p><strong>属性多值匹配</strong></p>
<p>　　这时如果属性有多个值就需要用 contains() 函数了，代码可以改写如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</div><div class="line">text = <span class="string">'''</span></div><div class="line">&lt;li class="li li-first"&gt;&lt;a href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;</div><div class="line">'''</div><div class="line">html = etree.HTML(text)</div><div class="line">result = html.xpath(<span class="string">'//li[contains(@class, "li")]/a/text()'</span>)</div><div class="line">print(result)</div></pre></td></tr></table></figure></p>
<p>　　这样我们通过 contains() 方法，第一个参数传入属性名称，第二个参数传入属性值，这样只要此属性包含所传入的属性值就可以完成匹配了。</p>
<p>　　运行结果：</p>
<pre><code>[&apos;first item&apos;]
</code></pre><p>　　此种选择方式在某个节点的某个属性有多个值的时候经常会用到，如某个节点的 class 属性通常有多个。</p>
<p><strong>多属性匹配</strong></p>
<p>　　外我们可能还遇到一种情况，我们可能需要根据多个属性才能确定一个节点，这是就需要同时匹配多个属性才可以，那么这里可以使用运算符 and 来连接，示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</div><div class="line">text = <span class="string">'''</span></div><div class="line">&lt;li class="li li-first" name="item"&gt;&lt;a href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;</div><div class="line">'''</div><div class="line">html = etree.HTML(text)</div><div class="line">result = html.xpath(<span class="string">'//li[contains(@class, "li") and @name="item"]/a/text()'</span>)</div><div class="line">print(result)</div></pre></td></tr></table></figure></p>
<p>　　在这里 HTML 文本的 li 节点又增加了一个属性 name，这时候我们需要同时根据 class 和 name 属性来选择，就可以 and 运算符连接两个条件，两个条件都被中括号包围，运行结果如下：</p>
<pre><code>[&apos;first item&apos;]
</code></pre><h2 id="4-2、BeautifulSoup使用"><a href="#4-2、BeautifulSoup使用" class="headerlink" title="4.2、BeautifulSoup使用"></a>4.2、BeautifulSoup使用</h2><p>　　BeautifulSoup提供一些简单的、Python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 BeautifulSoup 自动将输入文档转换为 Unicode 编码，输出文档转换为 utf-8 编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时你仅仅需要说明一下原始编码方式就可以了。 BeautifulSoup 已成为和 lxml、html6lib 一样出色的 Python 解释器，为用户灵活地提供不同的解析策略或强劲的速度。</p>
<p>　　BeautifulSoup 在解析的时候实际上是依赖于解析器的，它除了支持 Python 标准库中的 HTML 解析器，还支持一些第三方的解析器比如 LXML，LXML 这个解析器有解析 HTML 和 XML 的功能，而且速度快，容错能力强，所以推荐使用这个解析器来进行解析。</p>
<h2 id="4-3、PyQuery使用"><a href="#4-3、PyQuery使用" class="headerlink" title="4.3、PyQuery使用"></a>4.3、PyQuery使用</h2><p><strong>基本CSS选择器</strong></p>
<p>　　我们首先用一个实例来感受一下 PyQuery 的 CSS 选择器的用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">html = <span class="string">'''</span></div><div class="line">&lt;div id="container"&gt;</div><div class="line">    &lt;ul class="list"&gt;</div><div class="line">         &lt;li class="item-0"&gt;first item&lt;/li&gt;</div><div class="line">         &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</div><div class="line">         &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">         &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</div><div class="line">         &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;</div><div class="line">     &lt;/ul&gt;</div><div class="line"> &lt;/div&gt;</div><div class="line">'''</div><div class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</div><div class="line">doc = pq(html)</div><div class="line">print(doc(<span class="string">'#container .list li'</span>))</div><div class="line">print(type(doc(<span class="string">'#container .list li'</span>)))</div></pre></td></tr></table></figure></p>
<p>　　运行结果：</p>
<pre><code>&lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;
&lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;
&lt;class &apos;pyquery.pyquery.PyQuery&apos;&gt;
</code></pre><p>　　在这里我们初始化 PyQuery 对象之后，传入了一个 CSS 选择器，#container .list li，意思是选取 id 为 container 的节点内部的 class 为 list 的节点内部的所有 li 节点。然后打印输出，可以看到成功获取到了符合条件的节点。</p>
<p>　　然后我们将它的类型打印输出，可以看到它的类型依然是 PyQuery类型。</p>
<p><strong>获取属性</strong></p>
<p>　　提取到某个 PyQuery 类型的节点之后，我们可以调用 attr() 方法来获取属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">html = <span class="string">'''</span></div><div class="line">&lt;div class="wrap"&gt;</div><div class="line">    &lt;div id="container"&gt;</div><div class="line">        &lt;ul class="list"&gt;</div><div class="line">             &lt;li class="item-0"&gt;first item&lt;/li&gt;</div><div class="line">             &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</div><div class="line">             &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">             &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</div><div class="line">             &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;</div><div class="line">         &lt;/ul&gt;</div><div class="line">     &lt;/div&gt;</div><div class="line"> &lt;/div&gt;</div><div class="line">'''</div><div class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</div><div class="line">doc = pq(html)</div><div class="line">a = doc(<span class="string">'.item-0.active a'</span>)</div><div class="line">print(a, type(a))</div><div class="line">print(a.attr(<span class="string">'href'</span>))</div></pre></td></tr></table></figure></p>
<p>　　运行结果：</p>
<pre><code>&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt; &lt;class &apos;pyquery.pyquery.PyQuery&apos;&gt;
link3.html
</code></pre><p>　　在这里我们首先选中了 class 为 item-0 和 active 的 li 节点内的 a 节点，它的类型可以看到是 PyQuery 类型。然后我们调用了 attr() 方法，然后传入属性的名称，就可以得到这个属性值了。也可以通过调用 attr 属性来获取属性，用法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">    print(a.attr.href)</div><div class="line">```    </div><div class="line">　　结果：</div><div class="line"></div><div class="line">    link3.html</div><div class="line">    </div><div class="line">　　结果是完全一样的，在这里我们没有调用方法，而是调用了 attr 属性，然后再调用属性名，同样可以得到属性值。</div><div class="line"></div><div class="line">**获取文本**</div><div class="line"></div><div class="line">　　获取节点之后的另一个主要的操作就是获取其内部的文本了，我们可以调用 text() 方法来获取：</div><div class="line">```python</div><div class="line">    html = <span class="string">'''</span></div><div class="line">    &lt;div class="wrap"&gt;</div><div class="line">        &lt;div id="container"&gt;</div><div class="line">            &lt;ul class="list"&gt;</div><div class="line">                 &lt;li class="item-0"&gt;first item&lt;/li&gt;</div><div class="line">                 &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</div><div class="line">                 &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">                 &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</div><div class="line">                 &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;</div><div class="line">             &lt;/ul&gt;</div><div class="line">         &lt;/div&gt;</div><div class="line">     &lt;/div&gt;</div><div class="line">    '''</div><div class="line">    <span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</div><div class="line">    doc = pq(html)</div><div class="line">    a = doc(<span class="string">'.item-0.active a'</span>)</div><div class="line">    print(a)</div><div class="line">    print(a.text())</div></pre></td></tr></table></figure></p>
<p>　　运行结果：</p>
<pre><code>&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;
third item
</code></pre><p>　　我们首先选中了一个 a 节点，然后调用了 text() 方法，就可以获取其内部的文本信息了，它会忽略掉节点内部包含的所有 HTML，只返回纯文字内容。</p>
<p>　　但如果我们想要获取这个节点内部的 HTML 文本，就可以用 html() 方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</div><div class="line">doc = pq(html)</div><div class="line">li = doc(<span class="string">'.item-0.active'</span>)</div><div class="line">print(li)</div><div class="line">print(li.html())</div></pre></td></tr></table></figure></p>
<p>　　这里我们选中了第三个 li 节点，然后调用了 html() 方法，它返回的结果应该是li节点内的所有 HTML 文本。**获取节点之后的另一个主要的操作就是获取其内部的文本了，我们可以调用 text() 方法来获取：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">html = <span class="string">'''</span></div><div class="line">&lt;div class="wrap"&gt;</div><div class="line">    &lt;div id="container"&gt;</div><div class="line">        &lt;ul class="list"&gt;</div><div class="line">             &lt;li class="item-0"&gt;first item&lt;/li&gt;</div><div class="line">             &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</div><div class="line">             &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">             &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</div><div class="line">             &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;</div><div class="line">         &lt;/ul&gt;</div><div class="line">     &lt;/div&gt;</div><div class="line"> &lt;/div&gt;</div><div class="line">'''</div><div class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</div><div class="line">doc = pq(html)</div><div class="line">a = doc(<span class="string">'.item-0.active a'</span>)</div><div class="line">print(a)</div><div class="line">print(a.text())</div></pre></td></tr></table></figure></p>
<p>　　运行结果：</p>
<pre><code>&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;
third item
</code></pre><p>　　我们首先选中了一个 a 节点，然后调用了 text() 方法，就可以获取其内部的文本信息了，它会忽略掉节点内部包含的所有 HTML，只返回纯文字内容。但如果我们想要获取这个节点内部的 HTML 文本，就可以用 html() 方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</div><div class="line">    doc = pq(html)</div><div class="line">    li = doc(<span class="string">'.item-0.active'</span>)</div><div class="line">    print(li)</div><div class="line">    print(li.html())</div><div class="line">```  </div><div class="line">　　这里我们选中了第三个 li 节点，然后调用了 html() 方法，它返回的结果应该是li节点内的所有 HTML 文本。</div><div class="line"></div><div class="line"><span class="comment">## 4.4、文件存储</span></div><div class="line"></div><div class="line">**TXT文件存储：**</div><div class="line">```python</div><div class="line">    <span class="keyword">with</span> open(<span class="string">'explore.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</div><div class="line">        file.write(<span class="string">'\n'</span>.join([question, author, answer]))</div><div class="line">        file.write(<span class="string">'\n'</span> + <span class="string">'='</span> * <span class="number">50</span> + <span class="string">'\n'</span>)</div></pre></td></tr></table></figure></p>
<p>　　如果想保存时将原文清空，那么可以将第二个参数改写为 w</p>
<p><strong>JSON文件存储</strong></p>
<p>　　Json，全称为 JavaScript Object Notation, 也就是 JavaScript 对象标记，通过对象和数组的组合来表示数据，构造简洁但是结构化程度非常高，它是一种轻量级的数据交换格式</p>
<p>　　在 JavaScript 语言中，一切都是对象。因此，任何支持的类型都可以通过 Json 来表示，例如字符串、数字、对象、数组等。但是对象和数组是比较特殊且常用的两种类型。</p>
<ul>
<li>对象，对象在 JavaScript 中是使用花括号 {} 包裹起来的内容，数据结构为 {key1：value1, key2：value2, …} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。</li>
<li>数组，数组在 JavaScript 中是方括号 [] 包裹起来的内容，数据结构为 [“java”, “javascript”, “vb”, …] 的索引结构。在 JavaScript 中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引使用得多。同样，值的类型可以是任意类型。</li>
</ul>
<p>　　所以一个 Json 对象可以写为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">    [&#123;</div><div class="line">        <span class="string">"name"</span>: <span class="string">"Bob"</span>,</div><div class="line">        <span class="string">"gender"</span>: <span class="string">"male"</span>,</div><div class="line">        <span class="string">"birthday"</span>: <span class="string">"1992-10-18"</span></div><div class="line">    &#125;, &#123;</div><div class="line">         <span class="string">"name"</span>: <span class="string">"Selina"</span>,</div><div class="line">        <span class="string">"gender"</span>: <span class="string">"female"</span>,</div><div class="line">        <span class="string">"birthday"</span>: <span class="string">"1995-10-18"</span></div><div class="line">    &#125;]</div><div class="line">```    </div><div class="line">　　由中括号包围的就相当于列表类型，列表的每个元素可以是任意类型，在示例中它是字典类型，由大括号包围。Json 可以由以上两种形式自由组合而成，可以无限次嵌套，结构清晰，是数据交换的极佳方式。</div><div class="line"></div><div class="line">**CSV文件存储**</div><div class="line"></div><div class="line">　　CSV，全称叫做 Comma-Separated Values，中文可以叫做逗号分隔值或字符分隔值，其文件以纯文本形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分隔，每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符，不过所有记录都有完全相同的字段序列，相当于一个结构化表的纯文本形式，它相比 Excel 文件更加简介，XLS 文本是电子表格，它包含了文本、数值、公式和格式等内容，而 CSV 中不包含这些内容，就是特定字符分隔的纯文本，结构简单清晰，所以有时候我们用 CSV 来保存数据是比较方便的</div><div class="line"></div><div class="line"><span class="comment">## 4.5、关系型数据库</span></div><div class="line"></div><div class="line"><span class="comment">#### MySQL</span></div><div class="line"></div><div class="line">　　关系型数据库基于关系模型的数据库，而关系模型是通过二维表来保存的，所以它的存储方式就是行列组成的表，每一列是一个字段，每一行是一条记录。表可以看作是某个实体的集合，而实体之间存在联系，这就需要表与表之间的关联关系来体现，如主键外键的关联关系，多个表组成一个数据库，也就是关系型数据库。</div><div class="line"></div><div class="line">　　关系型数据库有多种，如 SQLite、MySQL、Oracle、SQL Server、DB2等等。</div><div class="line"></div><div class="line">详见[MySQLDB操作](https://henrybalthier.github.io/HenryBalthier.github.io/<span class="number">2017</span>/<span class="number">08</span>/<span class="number">22</span>/MySQLDB%EF%BC%<span class="number">9</span>APython%E4%BB%A3%E7%A0%<span class="number">81</span>%E7%BC%<span class="number">96</span>%E5%<span class="number">86</span>%<span class="number">99</span>/ <span class="string">""</span>)</div><div class="line"></div><div class="line"><span class="comment">## 4.6、非关系型数据库</span></div><div class="line"></div><div class="line">　　NoSQL，全称 Not Only SQL，意为不仅仅是 SQL，泛指非关系型的数据库。NoSQL 是基于键值对的，而且不需要经过 SQL 层的解析，数据之间没有耦合性，性能非常高。</div><div class="line"></div><div class="line">　　非关系型数据库又可以细分如下：</div><div class="line"></div><div class="line">* 键值存储数据库，代表有 Redis, Voldemort, Oracle BDB 等。</div><div class="line">* 列存储数据库，代表有 Cassandra, HBase, Riak 等。</div><div class="line">* 文档型数据库，代表有 CouchDB, MongoDB 等。</div><div class="line">* 图形数据库，代表有 Neo4J, InfoGrid, Infinite Graph等。</div><div class="line"></div><div class="line">　　对于爬虫的数据存储来说，一条数据可能存在某些字段提取失败而缺失的情况，而且数据可能随时调整，另外数据之间能还存在嵌套关系。如果我们使用了关系型数据库存储，一是需要提前建表，二是如果存在数据嵌套关系的话需要进行序列化操作才可以存储，比较不方便。如果用了非关系数据库就可以避免一些麻烦，简单高效。</div><div class="line"></div><div class="line"><span class="comment">#### 4.6.1、MongoDB</span></div><div class="line"></div><div class="line">**连接MongoDB**</div><div class="line"></div><div class="line">　　连接 MongoDB 我们需要使用 PyMongo 库里面的 MongoClient，一般来说传入 MongoDB 的 IP 及端口即可，第一个参数为地址 host，第二个参数为端口 port，端口如果不传默认是 <span class="number">27017</span>。</div><div class="line">```python</div><div class="line">    <span class="keyword">import</span> pymongo</div><div class="line">    client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>)</div></pre></td></tr></table></figure></p>
<p>　　这样我们就可以创建一个 MongoDB 的连接对象了。另外 MongoClient 的第一个参数 host 还可以直接传MongoDB 的连接字符串，以 mongodb 开头，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client = MongoClient(<span class="string">'mongodb://localhost:27017/'</span>)</div></pre></td></tr></table></figure></p>
<p>　　可以达到同样的连接效果。</p>
<p><strong>指定数据库</strong></p>
<p>　　MongoDB 中还分为一个个数据库，我们接下来的一步就是指定要操作哪个数据库，在这里我以 test 数据库为例进行说明，所以下一步我们需要在程序中指定要使用的数据库。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    db = client.test</div><div class="line">```    </div><div class="line">　　调用 client 的 test 属性即可返回 test 数据库，当然也可以这样来指定：</div><div class="line">```python</div><div class="line">    db = client[<span class="string">'test'</span>]</div><div class="line">```    </div><div class="line">　　两种方式是等价的。</div><div class="line"></div><div class="line">**指定集合**</div><div class="line"></div><div class="line">　　MongoDB 的每个数据库又包含了许多集合 Collection，也就类似与关系型数据库中的表，下一步我们需要指定要操作的集合，在这里我们指定一个集合名称为 students，学生集合，还是和指定数据库类似，指定集合也有两种方式：</div><div class="line">```python</div><div class="line">    collection = db.students</div><div class="line">    collection = db[<span class="string">'students'</span>]</div></pre></td></tr></table></figure></p>
<p>　　这样我们便声明了一个 Collection 对象。</p>
<p><strong>插入数据</strong></p>
<p>　　接下来我们便可以进行数据插入了，对于 students 这个Collection，我们新建一条学生数据，以字典的形式表示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">student = &#123;</div><div class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</div><div class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</div><div class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</div><div class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　在这里我们指定了学生的学号、姓名、年龄和性别，然后接下来直接调用 collection 的 insert() 方法即可插入数据，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = collection.insert(student)</div><div class="line">print(result)</div></pre></td></tr></table></figure></p>
<p>　　在 MongoDB 中，每条数据其实都有一个 _id 属性来唯一标识，如果没有显式指明 _id，MongoDB 会自动产生一个 ObjectId 类型的 _id 属性。insert() 方法会在执行后返回的 _id 值。</p>
<p>　　运行结果：</p>
<pre><code>5932a68615c2606814c91f3d
</code></pre><p>　　当然我们也可以同时插入多条数据</p>
<p><strong>查询</strong></p>
<p>　　插入数据后我们可以利用 find_one() 或 find() 方法进行查询，find_one() 查询得到是单个结果，find() 则返回一个生成器对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">result = collection.find_one(&#123;<span class="string">'name'</span>: <span class="string">'Mike'</span>&#125;)</div><div class="line">print(type(result))</div><div class="line">print(result)</div></pre></td></tr></table></figure></p>
<p>　　在这里我们查询 name 为 Mike 的数据，它的返回结果是字典类型。另外还可以对索引进行操作，如 create_index()、create_indexes()、drop_index() 等。详细用法可以参见官方文档：<a href="http://api.mongodb.com/python/current/api/pymongo/collection.html。" target="_blank" rel="external">http://api.mongodb.com/python/current/api/pymongo/collection.html。</a></p>
<p>　　另外还有对数据库、集合本身以及其他的一些操作，在这不再一一讲解，可以参见官方文档：<a href="http://api.mongodb.com/python/current/api/pymongo/。" target="_blank" rel="external">http://api.mongodb.com/python/current/api/pymongo/。</a></p>
<h4 id="4-6-2、Redis"><a href="#4-6-2、Redis" class="headerlink" title="4.6.2、Redis"></a>4.6.2、Redis</h4><p>　　Redis 是一个基于内存的高效的键值型非关系型数据库，存取效率极高，而且支持多种存储数据结构，使用也非常简单，在本节我们介绍一下 Python 的 Redis 操作，主要介绍 RedisPy 这个库的用法。</p>
<p>　　RedisPy 库提供两个类 Redis 和 StrictRedis 用于实现Redis 的命令操作。</p>
<p>　　StrictRedis 实现了绝大部分官方的命令，参数也一一对应，比如 set() 方法就对应 Redis 命令的 set 方法。而Redis 是 StrictRedis 的子类，它的主要功能是用于向后兼容旧版本库里的几个方法，为了做兼容，将方法做了改写，比如 lrem() 方法就将 value 和 num 参数的位置互换，和Redis 命令行的命令参数不一致。</p>
<p><strong>连接Redis</strong></p>
<p>　　当前在本地我已经安装了 Redis 并运行在 6379 端口，密码设置为 foobared。</p>
<p>　　那么可以用如下示例连接 Redis 并测试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis</div><div class="line"></div><div class="line">redis = StrictRedis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="string">'foobared'</span>)</div><div class="line">redis.set(<span class="string">'name'</span>, <span class="string">'Bob'</span>)</div><div class="line">print(redis.get(<span class="string">'name'</span>))</div></pre></td></tr></table></figure></p>
<p>　　在这里我们传入了 Redis 的地址，运行端口，使用的数据库，密码信息。在默认不传的情况下，这四个参数分别为 localhost、6379、0、None。现在我们声明了一个StrictRedis 对象，然后接下来调用了 set() 方法，设置一个键值对，然后在将其获取打印。</p>
<p>　　运行结果：</p>
<pre><code>b&apos;Bob&apos;
</code></pre><p>　　这样就说明我们连接成功，并可以执行 set()、get() 操作了。</p>
<p>　　当然我们还可以使用 ConnectionPool 来连接，示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</div><div class="line"></div><div class="line">pool = ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="string">'foobared'</span>)</div><div class="line">redis = StrictRedis(connection_pool=pool)</div></pre></td></tr></table></figure></p>
<p>　　这样的连接效果是一样的，观察源码可以发现 StrictRedis内其实就是用 host、port 等参数又构造了一个 ConnectionPool，所以我们直接将 ConnectionPool 当参数传给 StrictRedis 也是一样的。</p>
<p>　　具体操作可以参见文档: <a href="https://germey.gitbooks.io/python3webspider/content/5.3.2-Redis%E5%AD%98%E5%82%A8.html" target="_blank" rel="external">https://germey.gitbooks.io/python3webspider/content/5.3.2-Redis%E5%AD%98%E5%82%A8.html</a></p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="pagination" role="pagination">
    
    <a class="pull-left" href="/HenryBalthier.github.io/2017/08/31/【爬虫系列】5、动态页面抓取/" style="float: left;">
        ← 【爬虫系列】5、动态页面抓取
    </a>
    
    
    <a class="pull-right" href="/HenryBalthier.github.io/2017/08/29/【爬虫系列】3、基本使用/">
        【爬虫系列】3、基本使用 →
    </a>
    
</nav>

        <div class="duoshuo">


</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Yu Fangheng. All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/HenryBalthier.github.io/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/HenryBalthier.github.io/js/jquery.flexslider-min.js"></script><!-- Flexslider plugin -->
<script src="/HenryBalthier.github.io/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/HenryBalthier.github.io/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/HenryBalthier.github.io/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<!-- Initiate flexslider plugin -->
<script type="text/javascript">
    $(document).ready(function($) {
      (function(){
        console.log('font');
        var getCss = function(path) {
          var head = document.getElementsByTagName('head')[0];
          link = document.createElement('link');
          link.href = path;
          link.rel = 'stylesheet';
          link.type = 'text/css';
          head.appendChild(link);
        };
        getCss('https://fonts.googleapis.com/css?family=Montserrat:400,700');
        getCss('https://fonts.googleapis.com/css?family=Open+Sans:400,600');
      })();
      $('.flexslider').flexslider({
        animation: "fade",
        prevText: "",
        nextText: "",
        directionNav: true
      });
    });
</script>

</body>
</html>
